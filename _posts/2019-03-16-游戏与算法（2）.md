---
layout:     post
title:      游戏与算法（2）
subtitle:   常见的游戏和算法
date:       2019-03-16
author:     ls_oyang
header-img: img/post-bg-BJJ.jpg
catalog: true
tags:
    -game
---



##### 楼上鸡蛋扔几次

> 面前有100层楼，手中有两个完全一样的鸡蛋。已知在此楼某一临界层，在临界层之下的层往下扔鸡蛋，鸡蛋不破；在临界层之上的层往下扔鸡蛋，鸡蛋破。不破的鸡蛋可以多次使用。问如何扔鸡蛋可以最快确定临界层？（扔鸡蛋次数最少）（你要觉得鸡蛋实在不符现实就当是玻璃球吧）



这个题目的奇特之处在于每一次扔鸡蛋都面临两种情况，碎了或者没碎，碎了和没碎之后的策略是完全不同的：碎了的话只能从上一次扔鸡蛋的地方往上逐一试楼层，没碎的话就和以前一样，测试更高的楼层。

还有题目中的最少当然不是说偶然某种情况下最少，而是面临临界层可能在任何一层的情况下最优的策略。或者说每一种情况下（临界层在第一层扔鸡蛋的次数+临界层在第二层扔鸡蛋的次数+……+100层的次数）扔鸡蛋的次数的和最小。

一般来讲初步我们会想出两种方法：

二分法：先确认第50层，碎了从第一层开始往上逐一确认，没碎就再从75层开始，后面雷同。这个方法看起来不错，其实不只是对于临界在50层以上的情况确认稍快，而在50层以下，次数逐层递增，如果在49层就得扔50次，总之效果不佳，

十分法：第一个鸡蛋碎之前的确认楼层分别为10,20,……90，这样确实好很多，最多不会超过20次。

有没有更好的办法呢？

> 我们不妨将问题转换一下：题目主干和上面雷同，面对一栋楼，**临界层可能在任何一层**，两个鸡蛋**扔两次**我们可以确认高多少层的楼的临界层（碎或者不碎）？怎么扔呢？第一次在哪里开始？

这个我们要注意，我们只有两次机会，碎或者不碎都只有两次，因为每次扔鸡蛋都面临两种情况，碎或者不碎。可能碎，所以不能太高，太高的话如果碎了下面就没办法逐一确认了，不能太低，因为没碎下面楼层就不需要再确认，太低了就浪费了，本来我们可以多知道一个楼层的测试结果对吧，那多高合适呢？答案是第二层，因为碎了我们还有一次机会看第一层碎不碎。

那第二次在哪里呢？有人会说这不是看第一次碎没碎吗？如果碎了只能在第一层啊，好，那如果没碎呢？不要本能地认为还有两个鸡蛋应该从第四层开始，要知道，你只有一次机会了你只能确定第三层，因为如果在第四层碎了，你不知道临界层是第三层还是第四层，我们要考虑所有可能性。所以答案来了，两个鸡蛋两次机会，我们最高可以确认一栋（2+1）层楼的临界层（任何可能性下），注意是任何可能性下。

> 两个鸡蛋**三**次机会呢？

按照上面的思路：3+2+1=6，所以是6层。n次：n+(n-1)+……+2+1=（n+1）*n/2。

13次能确定91层，14次能确认105层，所以最初的题目答案出来了， 14次。

如此我们可以**定义两个鸡蛋扔n次能确定的楼高为：f(2,n)=(n+1)\*n/2** 。

> 三个鸡蛋呢？f(3,3)=？；三个鸡蛋扔n次f(3,n)=?

三个鸡蛋扔两次和两个鸡蛋扔两次是一样的，f(3,2)=3。三个鸡蛋扔三次，第一次从哪里开始？

开始的楼层怎么确定的呢？其实是在鸡蛋碎了的情况下，剩下的鸡蛋和次数可以检测完下面所有的楼层，由于 f（2,2）=3，所以三个鸡蛋扔三次的话，第一次应该从第四层开始，后面就是可以用递归解决的老问题。

f(3,3)=f(2,2)+1+f(3,2)=3+1+3=7。

当n>3,有f(3,n)=f(2,n-1)+1+f(3,n-1);

> m个鸡蛋，n次机会（n>m），f(m,n)=?

如上f(3,n)，有f(m,n)=f(m-1,n-1)+1+f(m,n-1) ;

递归代码如下：

```java
public class Main {
  public static void main(String[] args) {
    System.out.println(f(2,14));//105
    System.out.println(f(3,3));//7
    System.out.println(f(4,5));//30
  }
  //m个鸡蛋扔n次，
  static int f(int m,int n) {
    if(m==2) {
      return (n+1)*n/2;
    }else if(m>n) {
      return f(n,n);
    }else {
      return f(m-1,n-1)+1+f(m,n-1);
    }
  }
}
```

